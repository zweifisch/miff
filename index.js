// Generated by CoffeeScript 1.8.0
(function() {
  var __slice = [].slice;

  exports.parse = function(input, opts, result) {
    var char, equalSignSupport, first, idx, key, line, linenumber, parseBool, parseNumber, quotesSupport, section, sectionSupport, shift, value, _i, _len, _ref;
    quotesSupport = (opts != null ? opts.quote : void 0) || true;
    sectionSupport = (opts != null ? opts.section : void 0) || true;
    equalSignSupport = opts != null ? opts.equal : void 0;
    parseNumber = opts != null ? opts.number : void 0;
    parseBool = opts != null ? opts.bool : void 0;
    if (result == null) {
      result = {};
    }
    section = result;
    _ref = input.split(/[\r\n]+/);
    for (linenumber = _i = 0, _len = _ref.length; _i < _len; linenumber = ++_i) {
      line = _ref[linenumber];
      line = line.trim();
      if (!line) {
        continue;
      }
      first = line.charAt(0);
      if (first === ';' || first === '#') {
        continue;
      }
      if (sectionSupport && first === '[') {
        if (line.charAt(line.length - 1) === ']') {
          section = result[line.substr(1, line.length - 2)] = {};
          continue;
        } else {
          throw "section header not closed on " + (linenumber + 1);
        }
      }
      shift = 1;
      while (true) {
        idx = line.indexOf('=', shift);
        if (idx === -1) {
          throw new Error("'=' not found on line " + (linenumber + 1) + " '" + line + "'");
        }
        if (equalSignSupport) {
          if ('\\' !== line.charAt(idx - 1)) {
            key = (line.substr(0, idx)).split('\\=').join('=');
            value = line.substr(idx + 1);
            break;
          } else {
            shift = idx + 1;
          }
        } else {
          key = line.substr(0, idx);
          value = line.substr(idx + 1);
          break;
        }
      }
      value = value.trimLeft();
      key = key.trimRight();
      if (quotesSupport) {
        char = value.charAt(0);
        if (char === '"' && value.charAt(value.length - 1) === '"') {
          section[key] = value.substr(1, value.length - 2);
          continue;
        } else if (char === "'" && value.charAt(value.length - 1) === "'") {
          section[key] = value.substr(1, value.length - 2);
          continue;
        }
      }
      if (parseBool) {
        if (value === 'on' || value === 'true') {
          section[key] = true;
          continue;
        } else if (value === 'off' || value === 'false') {
          section[key] = false;
          continue;
        }
      }
      if (parseNumber) {
        if (!isNaN(parseFloat(value)) && isFinite(value)) {
          section[key] = parseFloat(value);
          continue;
        }
      }
      section[key] = value;
    }
    return result;
  };

  exports.load = function() {
    var file, files, fs, opts, ret, _i, _j, _len;
    files = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), opts = arguments[_i++];
    fs = require('fs');
    ret = {};
    if ('object' !== typeof opts) {
      files.push(opts);
      opts = null;
    }
    for (_j = 0, _len = files.length; _j < _len; _j++) {
      file = files[_j];
      exports.parse(fs.readFileSync(file, {
        encoding: 'utf8'
      }), opts, ret);
    }
    return ret;
  };

  exports.stringify = function(dict) {
    var EOL, escapeEq, escapeQuote, stringify;
    EOL = require('os').EOL;
    escapeEq = function(str) {
      return str.replace(/\=/g, '\\=');
    };
    escapeQuote = function(str) {
      return str.replace(/'/g, "'");
    };
    stringify = function(kv) {
      var k, ret, v;
      ret = '';
      for (k in kv) {
        v = kv[k];
        if ('object' === typeof v) {
          ret += "" + EOL + "[" + k + "]" + EOL;
          ret += stringify(v);
        } else if ('string' === typeof v) {
          if ('true' === v || 'false' === v) {
            ret += "" + (escapeEq(k)) + " = '" + v + "'" + EOL;
          } else if ((' ' === v.charAt(0)) || (' ' === v.charAt(v.length - 1))) {
            ret += "" + (escapeEq(k)) + " = '" + (escapeQuote(v)) + "'" + EOL;
          } else {
            ret += "" + (escapeEq(k)) + " = " + v + EOL;
          }
        } else {
          ret += "" + (escapeEq(k)) + " = " + v + EOL;
        }
      }
      return ret;
    };
    return stringify(dict);
  };

  exports.dump = function(dict, file) {
    var fs;
    fs = require('fs');
    return fs.writeFileSync(file, exports.stringify(dict), {
      encoding: 'utf8'
    });
  };

}).call(this);
